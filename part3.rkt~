; If you are using scheme instead of racket, comment these two lines, uncomment the (load "simpleParser.scm") and comment the (require "simpleParser.rkt")
#lang racket
(require "functionParser.rkt")
; A simple interpreter for Java
; Daniel Schnabel, Anthony Testa, and Oliver Traben
; 4/12/2021


; An interpreter for the simple language that uses call/cc for the continuations.  Does not handle side effects.
(define call/cc call-with-current-continuation)


; The functions that start interpret-...  all return the current environment.
; The functions that start eval-...  all return a value

; The main function.  Calls parser to get the parse tree and interprets it with a new environment.  The returned value is in the environment.
(define interpret
  (lambda (file)
    (scheme->language
     (call/cc
      (lambda (return)
        (interpret-definitions-list (parser file) (newenvironment) return
                                  (lambda (env) (myerror "Break used outside of loop"))
                                  (lambda (env) (myerror "Continue used outside of loop"))
                                  (lambda (v env) (myerror "Uncaught exception thrown"))
                                  (parser file)))))))

; interprets a list of global variable definitions and function definitions.
; This gets called on first to get all global variable and function definitions in the outer layer of the environment.
; once the entire statement-list of definitions is interpreted (i.e. it is null),
; interpret-main is called on so the main function of the code can be run next.
(define interpret-definitions-list
  (lambda (statement-list environment return break continue throw original-statement-list)
    (if (null? statement-list)
        (interpret-main original-statement-list environment return break continue throw)
        (interpret-definitions-list (get-the-rest statement-list)
                                    (interpret-definitions (statement-type statement-list) environment
                                                           return break continue throw original-statement-list)
                                    return break continue throw original-statement-list))))

; interprets a single statement definition. Since only global variable and function definitions will be in the outer layer,
; only function, var, and = statement-types are accounted for.
(define interpret-definitions
  (lambda (statement environment return break continue throw original-statement-list)
    (cond
      ((eq? 'function (statement-type statement))
       (interpret-function-definition statement environment return break continue throw))
      ((eq? 'var (statement-type statement))
       (interpret-declare statement environment throw))
      ((eq? '= (statement-type statement))
       (interpret-assign statement environment throw))
      (else (myerror "Unknown statement:" (statement-type statement))))))

; locates the main function in the statement-list, and calls interpret-statement-list on the body of it.
(define interpret-main
  (lambda (statement-list environment return break continue throw)
    (cond
      ((null? statement-list)
       ('error "no main function"))
      ((and (eq? (get-statement-type statement-list) 'function) (eq? (get-function statement-list) 'main))
       (interpret-statement-list (get-main-body statement-list)
                                 (push-frame environment)
                                 return break continue throw))
      (else (interpret-main (get-the-rest statement-list)
                            environment return break continue throw)))))

; interprets a list of statements.  The environment from each statement is used for the next ones.
; Mstate (<statement><statement-list>, state) = Mstate(<statement-list>, Mstate(<statement>, state))
(define interpret-statement-list
  (lambda (statement-list environment return break continue throw)
    (if (null? statement-list)
        environment
        (interpret-statement-list (get-the-rest statement-list)
                                  (interpret-statement (statement-type statement-list)
                                                       environment return break continue throw)
                                  return break continue throw))))

; interpret a statement in the environment with continuations for return, break, continue, throw
(define interpret-statement
  (lambda (statement environment return break continue throw)
    (cond
      ((eq? 'function (statement-type statement)) (interpret-function-definition statement environment return break continue throw))
      ((eq? 'funcall (statement-type statement)) (interpret-function-state statement environment return break continue throw))
      ((eq? 'return (statement-type statement)) (interpret-return statement environment return throw))
      ((eq? 'var (statement-type statement)) (interpret-declare statement environment throw))
      ((eq? '= (statement-type statement)) (interpret-assign statement environment throw))
      ((eq? 'if (statement-type statement)) (interpret-if statement environment return break continue throw))
      ((eq? 'while (statement-type statement)) (interpret-while statement environment return throw))
      ((eq? 'continue (statement-type statement)) (continue environment))
      ((eq? 'break (statement-type statement)) (break environment))
      ((eq? 'begin (statement-type statement)) (interpret-block statement environment return break continue throw))
      ((eq? 'throw (statement-type statement)) (interpret-throw statement environment throw))
      ((eq? 'try (statement-type statement)) (interpret-try statement environment return break continue throw))
      (else (myerror "Unknown statement:" (statement-type statement))))))

; interpret-function for a given function name as a statement in the environment with continuations for return, break, continue, throw
(define interpret-function-definition
  (lambda (statement environment return break continue throw)
    (insert (get-function-name statement) (make-closure statement environment) environment)))

; helper method to create function closure, as defined in the denotational semantics
(define make-closure
  (lambda (statement environment)
    (list (get-formal-params statement) (get-function-body statement)
          (lambda (env) (function-environment statement (get-outer-layer-vlist env) env)))))

; helper method to create the function environment. Called on from the function within the closure
; if a function definition is a member in another function's body, then that function's environment is passed through
(define function-environment
  (lambda (statement outerlayer-vlist environment)
    (cond
      ((null? outerlayer-vlist)
       (list (get-outer-layer environment)))
      ((or (number? (unbox (get-closure outerlayer-vlist))) (eq? (length (unbox (get-closure outerlayer-vlist))) 1))
       (function-environment statement
                             (get-the-rest outerlayer-vlist) environment))
      ((member?* 'function (get-closure-body (unbox (get-closure outerlayer-vlist))))
       environment)
      (else (function-environment statement (get-the-rest outerlayer-vlist) environment)))))

; M-integer interpret function, identifies the return-value for a given function in the environment with a continuation for throw
(define interpret-function-integer
  (lambda (statement environment throw)
    (
     (lambda (return)
      (let* ((closure (lookup (get-function-name statement) environment))
           (fstate1 ((get-closure-environment closure) environment))
           (fstate2 (push-frame fstate1))
           (fstate3
            (bind-parameters (get-closure-formal-params closure)
                             (get-argument-list statement)
                             fstate2 environment throw)))
      (if (not (eq? (length (get-closure-formal-params closure)) (length (get-funcall-params statement))))
        (myerror "Error: mismatched-number-of-parameters")
        (interpret-statement-list (get-closure-body closure) fstate3 return
                                  (lambda (s) ('error "break-out-of-loop"))
                                  (lambda (s) ('error "no-return-statement"))
                                  throw)))))))

; M-state interpret function, updates the environment with the given function with continuations for return, break, continue, throw
(define interpret-function-state
  (lambda (statement environment return break continue throw)
    (let* ((closure (lookup (get-function-name statement) environment))
           (fstate1 ((get-closure-environment closure) environment))
           (fstate2 (push-frame fstate1))
           (fstate3
            (bind-parameters (get-closure-formal-params closure)
                             (get-argument-list statement)
                             fstate2 environment throw)))
      (if (not (eq? (length (get-closure-formal-params closure)) (length (get-funcall-params statement))))
        (myerror "Error: mismatched-number-of-parameters")
        (interpret-statement-list (get-closure-body closure) fstate3
                                (lambda (v) environment)
                                (lambda (s) ('error "break-out-of-loop"))
                                (lambda (s) (continue s))
                                throw)))))

; binds the actual parameters to the formal parameters
(define bind-parameters
  (lambda (params args fstate environment throw)
    (if (null? params)
        fstate
        (bind-parameters (get-the-rest params) (get-the-rest args)
                         (insert (get-var-params params) (eval-expression (get-expr-args args) environment throw) fstate)
                         environment throw))))

      
; Calls the return continuation with the given expression value
(define interpret-return
  (lambda (statement environment return throw)
        (return (eval-expression (get-expr statement) environment throw))))

; Adds a new variable binding to the environment.  There may be an assignment with the variable
(define interpret-declare
  (lambda (statement environment throw)
    (if (exists-declare-value? statement)
        (insert (get-declare-var statement)
                (eval-expression (get-declare-value statement) environment throw) environment)
        (insert (get-declare-var statement) 'novalue environment))))

; Updates the environment to add an new binding for a variable
(define interpret-assign
  (lambda (statement environment throw)
    (update (get-assign-lhs statement)
            (eval-expression (get-assign-rhs statement) environment throw)
            environment)))

; We need to check if there is an else condition.  Otherwise, we evaluate the expression and do the right thing.
(define interpret-if
  (lambda (statement environment return break continue throw)
    (cond
      ((eval-expression (get-condition statement) environment throw)
       (interpret-statement (get-then statement)
                            environment return break continue throw))
      ((exists-else? statement)
       (interpret-statement (get-else statement)
                            environment return break continue throw))
      (else environment))))

; Interprets a while loop.  We must create break and continue continuations for this loop
(define interpret-while
  (lambda (statement environment return throw)
    (call/cc
     (lambda (break)
       (letrec ((loop (lambda (condition body environment)
                        (if (eval-expression condition environment throw)
                            (loop condition body
                                  (interpret-statement body environment return break
                                                       (lambda (env) (break (loop condition body env)))
                                                       throw))
                         environment))))
         (loop (get-condition statement) (get-body statement) environment))))))

; Interprets a block.  The break, continue, and throw continuations must be adjusted to pop the environment
; Mstate({ <body> }, state) = pop-frame (Mstate (<body>, pushframe(state)))
(define interpret-block
  (lambda (statement environment return break continue throw)
    (pop-frame (interpret-statement-list (get-the-rest statement)
                                         (push-frame environment)
                                         return
                                         (lambda (env) (break (pop-frame env)))
                                         (lambda (env) (continue (pop-frame env)))
                                         (lambda (v env) (throw v (pop-frame env)))))))

; We use a continuation to throw the proper value. Because we are not using boxes,
; the environment/state must be thrown as well so any environment changes will be kept
(define interpret-throw
  (lambda (statement environment throw)
    (throw (eval-expression (get-expr statement) environment throw) environment)))


; Interpret a try-catch-finally block:

; Create a continuation for the throw.  If there is no catch, it has to interpret the finally block, and once that completes throw the exception.
; Otherwise, it interprets the catch block with the exception bound to the thrown value and interprets the finally block when the catch is done
(define create-throw-catch-continuation
  (lambda (catch-statement environment return break continue throw jump finally-block)
    (cond
      ((null? catch-statement)
       (lambda (ex env) (throw ex (interpret-block finally-block env return break continue throw)))) 
      ((not (eq? 'catch (statement-type catch-statement)))
       (myerror "Incorrect catch statement"))
      (else (lambda (ex env)
              (jump (interpret-block finally-block
                                     (pop-frame (interpret-statement-list 
                                                 (get-body catch-statement) 
                                                 (insert (catch-var catch-statement) ex (push-frame environment))
                                                 return 
                                                 (lambda (env2) (break (pop-frame env2))) 
                                                 (lambda (env2) (continue (pop-frame env2))) 
                                                 (lambda (v env2) (throw v (pop-frame env2)))))
                                     return break continue throw)))))))

; To interpret a try block, we must adjust  the return, break, continue continuations to interpret the finally block if any of them are used.
; Creates a new throw continuation and then interpret the try block with the new continuations followed by the finally block with the old continuations
(define interpret-try
  (lambda (statement environment return break continue throw)
    (call/cc
     (lambda (jump)
       (let* ((finally-block (make-finally-block (get-finally statement)))
              (try-block (make-try-block (get-try statement)))
              (new-return
               (lambda (v) (begin
                             (interpret-block finally-block environment return break continue throw)
                             (return v))))
              (new-break
               (lambda (env) (break
                              (interpret-block finally-block env return break continue throw))))
              (new-continue
               (lambda (env) (continue
                              (interpret-block finally-block env return break continue throw))))
              (new-throw
               (create-throw-catch-continuation
                (get-catch statement)
                environment return break continue throw jump finally-block)))
         (interpret-block finally-block
                          (interpret-block try-block environment new-return new-break new-continue new-throw)
                          return break continue throw))))))

; helper methods so that to reuse the interpret-block method on the try and finally blocks
(define make-try-block
  (lambda (try-statement)
    (cons 'begin try-statement)))

; helper methof to manually create a block for a finally statement using 'begin
(define make-finally-block
  (lambda (finally-statement)
    (cond
      ((null? finally-statement)
       '(begin))
      ((not (eq? (statement-type finally-statement) 'finally))
       (myerror "Incorrectly formatted finally block"))
      (else (cons 'begin (cadr finally-statement))))))


; Evaluates all possible boolean and arithmetic expressions, including constants and variables.
(define eval-expression
  (lambda (expr environment throw)
    (cond
      ((number? expr)
       expr)
      ((eq? expr 'true)
       #t)
      ((eq? expr 'false)
       #f)
      ((not (list? expr))
       (lookup expr environment))
      ((eq? 'funcall (operator expr))
       (interpret-function-integer expr environment throw))
      (else (eval-operator expr environment throw)))))

; Evaluate a binary (or unary) operator.  Although this is not dealing with side effects, I have the routine evaluate the left operand first and then
; pass the result to eval-binary-op2 to evaluate the right operand.  This forces the operands to be evaluated in the proper order in case you choose
; to add side effects to the interpreter
(define eval-operator
  (lambda (expr environment throw)
    (cond
      ((eq? '! (operator expr))
       (not (eval-expression (operand1 expr) environment throw)))
      ((and (eq? '- (operator expr)) (= 2 (length expr)))
       (- (eval-expression (operand1 expr) environment throw)))
      (else (eval-binary-op2 expr (eval-expression (operand1 expr) environment throw) environment throw)))))

; Complete the evaluation of the binary operator by evaluating the second operand and performing the operation.
(define eval-binary-op2
  (lambda (expr op1value environment throw)
    (cond
      ((eq? '+ (operator expr)) (+ op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '- (operator expr)) (- op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '* (operator expr)) (* op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '/ (operator expr)) (quotient op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '% (operator expr)) (remainder op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '== (operator expr)) (isequal op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '!= (operator expr)) (not (isequal op1value (eval-expression (operand2 expr) environment throw))))
      ((eq? '< (operator expr)) (< op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '> (operator expr)) (> op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '<= (operator expr)) (<= op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '>= (operator expr)) (>= op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '|| (operator expr)) (or op1value (eval-expression (operand2 expr) environment throw)))
      ((eq? '&& (operator expr)) (and op1value (eval-expression (operand2 expr) environment throw)))
      (else (myerror "Unknown operator:" (operator expr))))))

; Determines if two values are equal.  We need a special test because there are both boolean and integer types.
(define isequal
  (lambda (val1 val2)
    (if (and (number? val1) (number? val2))
        (= val1 val2)
        (eq? val1 val2))))


;-----------------
; HELPER FUNCTIONS
;-----------------

; These helper functions define the operator and operands of a value expression
(define operator car)
(define operand1 cadr)
(define operand2 caddr)
(define operand3 cadddr)

; These two helper functions check if particular operands exist or not
; check for operand2
(define exists-operand2?
  (lambda (statement)
    (not (null? (cddr statement)))))

; check for operand3
(define exists-operand3?
  (lambda (statement)
    (not (null? (cdddr statement)))))

; These helper functions define the parts of the various statement types
(define statement-type operator)
(define get-expr operand1)
(define get-function-name operand1)
(define get-formal-params operand2)
(define get-function-body operand3)
(define get-funcall-params cddr)
(define get-var-params car)
(define get-expr-args car)
(define get-closure-environment caddr)
(define get-closure-formal-params car)
(define get-closure-body cadr)
(define get-argument-list cddr)
(define get-declare-var operand1)
(define get-declare-value operand2)
(define exists-declare-value? exists-operand2?)
(define get-assign-lhs operand1)
(define get-assign-rhs operand2)
(define get-condition operand1)
(define get-then operand2)
(define get-else operand3)
(define get-body operand2)
(define exists-else? exists-operand3?)
(define get-try operand1)
(define get-catch operand2)
(define get-finally operand3)
(define get-closure car)
(define get-the-rest cdr)

; method that attatches operand1 to a given statement, particularlly the catch statement
(define catch-var
  (lambda (catch-statement)
    (car (operand1 catch-statement))))

; abstractions for interpret-main
(define get-statement-type caar)
(define get-function cadar)
(define get-main-body
  (lambda (statement-list)
    (car (cdddar statement-list))))

;------------------------
; Environment/State Functions
;------------------------

; returns the variable list of the environment
(define get-vlist
  (lambda (env)
    (cond
      ((null? env)
       '())
      (else (cons (caar env) (get-vlist (cdr env)))))))

; returns the assigned-value list of the environment
(define get-alist
  (lambda (env)
    (cond
      ((null? env)
       '())
      (else (cons (cadar env) (get-alist (cdr env)))))))

; returns the outermost layer's variable list
(define get-outer-layer-vlist
  (lambda (environment)
    (cadr (get-outer-layer environment))))

; returns the outermost layer of the state
(define get-outer-layer
  (lambda (environment)
    (cond
      ((null? (cdr environment))
       (car environment))
      (else (get-outer-layer (cdr environment))))))

; create a new empty environment
(define newenvironment
  (lambda ()
    (list (newframe))))

; create an empty frame: a frame is two lists, the first are the variables and the second is the "store" of values
(define newframe
  (lambda ()
    '(() ())))

; add a frame onto the top of the environment
(define push-frame
  (lambda (environment)
    (cons (newframe) environment)))

; remove a frame from the environment
(define pop-frame
  (lambda (environment)
    (if (null? (cdr environment))
        environment
        (cdr environment))))

; abstractions for parts of a given frame
(define topframe car)
(define remainingframes cdr)

; does a variable exist in the environment?
(define exists?
  (lambda (var environment)
    (cond
      ((null? environment)
       #f)
      ((exists-in-list? var (variables (topframe environment)))
       #t)
      (else (exists? var (remainingframes environment))))))

; does a variable exist in a list?
(define exists-in-list?
  (lambda (var l)
    (cond
      ((null? l)
       #f)
      ((eq? var (car l))
       #t)
      (else (exists-in-list? var (cdr l))))))

; Looks up a value in the environment.  If the value is a boolean, it converts our languages boolean type to a Scheme boolean type
(define lookup
  (lambda (var environment)
    (lookup-variable var environment)))
  
; A helper function that does the lookup.  Returns an error if the variable does not have a legal value
(define lookup-variable
  (lambda (var environment)
    (let ((value (lookup-in-env var environment)))
      (if (eq? 'novalue (unbox value))
          (myerror "error: variable without an assigned value:" var)
          (unbox value)))))

; Return the value bound to a variable in the environment
(define lookup-in-env
  (lambda (var environment)
    (cond
      ((null? environment)
       (myerror "error: undefined variable" var))
      ((exists-in-list? var (variables (topframe environment)))
       (lookup-in-frame var (topframe environment)))
      (else (lookup-in-env var (cdr environment))))))

; Return the value bound to a variable in the frame
(define lookup-in-frame
  (lambda (var frame)
    (cond
      ((not (exists-in-list? var (variables frame)))
       (myerror "error: undefined variable" var))
      (else (language->scheme (get-value (indexof var (variables frame)) (store frame)))))))

; Get the location of a name in a list of names
(define indexof
  (lambda (var l)
    (cond
      ((null? l) ; should not happen
       0)
      ((eq? var (car l))
       0)
      (else (+ 1 (indexof var (cdr l)))))))

; Get the value stored at a given index in the list
(define get-value
  (lambda (n l)
    (cond
      ((zero? n)
       (car l))
      (else (get-value (- n 1) (cdr l))))))

; Adds a new variable/value binding pair into the environment.  Gives an error if the variable already exists in this frame.
(define insert
  (lambda (var val environment)
    (if (exists-in-list? var (variables (car environment)))
        (myerror "error: variable is being re-declared:" var)
        (cons (add-to-frame var (box val) (car environment))
              (cdr environment)))))

; Changes the binding of a variable to a new value in the environment.  Gives an error if the variable does not exist.
(define update
  (lambda (var val environment)
    (if (exists? var environment)
        (update-existing var val environment)
        (myerror "error: variable used but not defined:" var))))

; Add a new variable/value pair to the frame.
(define add-to-frame
  (lambda (var val frame)
    (list (cons var (variables frame))
          (cons (scheme->language val) (store frame)))))

; Changes the binding of a variable in the environment to a new value
(define update-existing
  (lambda (var val environment)
    (if (exists-in-list? var (variables (car environment)))
        (cons (update-in-frame var val (topframe environment))
              (remainingframes environment))
        (cons (topframe environment)
              (update-existing var val (remainingframes environment))))))

; Changes the binding of a variable in the frame to a new value.
(define update-in-frame
  (lambda (var val frame)
    (list (variables frame)
          (update-in-frame-store var val (variables frame) (store frame)))))

; Changes a variable binding by placing the new value in the appropriate place in the store
(define update-in-frame-store
  (lambda (var val varlist vallist)
    (cond
      ((eq? var (car varlist))
       (cons (boxsetter (car vallist) (scheme->language val))
             (cdr vallist)))
      (else (cons (car vallist)
                  (update-in-frame-store var val (cdr varlist) (cdr vallist)))))))

; Returns the list of variables from a frame
(define variables
  (lambda (frame)
    (car frame)))

; Returns the store from a frame
(define store
  (lambda (frame)
    (cadr frame)))

; Functions to convert the Scheme #t and #f to our languages true and false, and back.
; language booleans to scheme
(define language->scheme
  (lambda (v) 
    (cond 
      ((eq? v 'false)
       #f)
      ((eq? v 'true)
       #t)
      (else v))))

; scheme booleans to language
(define scheme->language
  (lambda (v)
    (cond
      ((eq? v #f)
       'false)
      ((eq? v #t)
       'true)
      (else v))))

; Because the error function is not defined in R5RS scheme, I create my own:
(define error-break (lambda (v) v))
(call-with-current-continuation (lambda (k) (set! error-break k)))

(define myerror
  (lambda (str . vals)
    (letrec ((makestr (lambda (str vals)
                        (if (null? vals)
                            str
                            (makestr (string-append str
                                                    (string-append " " (symbol->string (car vals))))
                                     (cdr vals))))))
      (error-break (display (string-append str (makestr "" vals)))))))

; member?*: determines if an atom is inside a list (possibly a list of lists)
(define member?*
  (lambda (a list)
    (cond
      ((null? list)
       #f)
      ((list? (car list))
       (or (member?* a (car list))
           (member?* a (cdr list))))
      ((eq? a (car list))
       #t)
      (else (member?* a (cdr list))))))

; myappend-cps
; given in class
(define myappend-cps
  (lambda (list1 list2 return)
    (cond
      ((null? list1) (return list2))
      (else (myappend-cps (cdr list1) list2 (lambda (v) (return (cons (car list1) v))))))))

; flatten-cps: '(a (b c (d e)) (f)))) => '(a b c d e f)
; given in class
(define flatten-cps
  (lambda (list return)
    (cond
      ((null? list) (return '()))
      ((list? (car list)) (flatten-cps (car list) (lambda (v1) (flatten-cps (cdr list) (lambda (v2) (myappend-cps v1 v2 return))))))
      (else (flatten-cps (cdr list) (lambda (v) (return (cons (car list) v))))))))

; Helper method that calls the non functional set-box! on a box and a value to update the box, and then manually returns the updated box.
(define boxsetter
  (lambda (box thing)
    (begin (set-box! box thing) box)))